# Payment model -- tracks Razorpay payment transactions linked to bookings
import datetime

import sqlalchemy
from sqlalchemy.orm import Mapped as SQLAlchemyMapped, mapped_column as sqlalchemy_mapped_column, relationship

from src.repository.table import Base


# Database model for payment records, integrating with the Razorpay payment gateway
# Each payment is tied to a specific booking and user, tracking the full payment lifecycle
class Payment(Base):
    """
    Payment record tracking Razorpay transactions.
    """
    __tablename__ = "payment"

    # Primary key, auto-incrementing integer
    id: SQLAlchemyMapped[int] = sqlalchemy_mapped_column(
        primary_key=True, autoincrement=True
    )
    # Link to booking
    # Foreign key to the booking this payment is for; cascades on booking deletion
    booking_id: SQLAlchemyMapped[int] = sqlalchemy_mapped_column(
        sqlalchemy.ForeignKey("booking.id", ondelete="CASCADE"), nullable=False
    )
    # Foreign key to the user who made the payment; cascades on user deletion
    user_id: SQLAlchemyMapped[int] = sqlalchemy_mapped_column(
        sqlalchemy.ForeignKey("account.id", ondelete="CASCADE"), nullable=False
    )
    # Razorpay IDs
    # Unique order ID generated by Razorpay when the payment is initiated
    razorpay_order_id: SQLAlchemyMapped[str] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=100), nullable=False, unique=True
    )
    # Payment ID assigned by Razorpay after payment is authorized/captured
    razorpay_payment_id: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=100), nullable=True
    )
    # Signature from Razorpay used to verify payment authenticity
    razorpay_signature: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=500), nullable=True
    )
    # Amount in paise (smallest currency unit)
    # Stored in paise (1 INR = 100 paise) to avoid floating-point precision issues
    amount: SQLAlchemyMapped[int] = sqlalchemy_mapped_column(
        sqlalchemy.Integer, nullable=False
    )
    # ISO 4217 currency code, defaults to Indian Rupees (INR)
    currency: SQLAlchemyMapped[str] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=10), nullable=False, default="INR"
    )
    # Status
    # Payment lifecycle status: created, authorized, captured, failed, or refunded
    status: SQLAlchemyMapped[str] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=50), nullable=False, default="created"
    )  # created, authorized, captured, failed, refunded
    # Payment method details
    # The payment method used (e.g., card, upi, netbanking, wallet)
    method: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=50), nullable=True
    )  # card, upi, netbanking, wallet
    # Error tracking
    # Error code returned by Razorpay if the payment fails
    error_code: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=100), nullable=True
    )
    # Human-readable error description from the payment gateway
    error_description: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=500), nullable=True
    )
    # Refund tracking
    # Razorpay refund ID, populated when a refund is initiated
    refund_id: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=100), nullable=True
    )
    # Amount refunded in paise; may be partial or full
    refund_amount: SQLAlchemyMapped[int | None] = sqlalchemy_mapped_column(
        sqlalchemy.Integer, nullable=True
    )
    # Status of the refund: pending, processed, or failed
    refund_status: SQLAlchemyMapped[str | None] = sqlalchemy_mapped_column(
        sqlalchemy.String(length=50), nullable=True
    )  # pending, processed, failed
    # Timestamps
    # When the payment record was created (order initiated)
    created_at: SQLAlchemyMapped[datetime.datetime] = sqlalchemy_mapped_column(
        sqlalchemy.DateTime(timezone=True),
        nullable=False,
        server_default=sqlalchemy.func.now(),
    )
    # When the payment was successfully captured/authorized
    paid_at: SQLAlchemyMapped[datetime.datetime | None] = sqlalchemy_mapped_column(
        sqlalchemy.DateTime(timezone=True), nullable=True
    )
    # When the refund was processed
    refunded_at: SQLAlchemyMapped[datetime.datetime | None] = sqlalchemy_mapped_column(
        sqlalchemy.DateTime(timezone=True), nullable=True
    )

    # Eagerly load server-generated defaults after insert/update
    __mapper_args__ = {"eager_defaults": True}

    # Indexes for frequent query patterns: lookup by booking, user, order ID, and status
    __table_args__ = (
        sqlalchemy.Index("ix_payment_booking", "booking_id"),
        sqlalchemy.Index("ix_payment_user", "user_id"),
        sqlalchemy.Index("ix_payment_order_id", "razorpay_order_id"),
        sqlalchemy.Index("ix_payment_status", "status"),
    )

    # Relationships
    # Many-to-one: each payment is linked to one booking; eager-loaded via JOIN
    booking = relationship("Booking", lazy="joined")
    # Many-to-one: each payment is linked to one user; eager-loaded via JOIN
    user = relationship("Account", lazy="joined")

    def __repr__(self) -> str:
        return f"<Payment(id={self.id}, order_id='{self.razorpay_order_id}', status='{self.status}')>"
